# SOLID

### SOLID 원칙
* 객체지향 프로그래밍 및 설계에 필요한 기본 원칙. 아래 다섯가지로 구분할 수 있음.

<br>

### 단일 책임 원칙(SRP, Single Responsibility Principle)
* 객체지향 프로그래밍의 생산성을 높이기 위해 클래스가 제공하는 서비스는 오직 하나의 책임을 수행하는데 집중되어야 함.
  * 여기서 언급하는 "책임"의 의미는 해야하는 것을 잘 할수 있는 것을 의미함.
  * 모종의 이유로 하나의 클래스를 변경해야할 때, 그 이유는 오직 하나뿐이어야 함.
* 책임의 분배를 통한 클래스별 역할구분을 확실하게 함으로써, 코드의 가독성을 올리고 유지보수성을 향상시킬 수 있음.
* Spring Data JPA를 사용하는 경우, Repository를 따로 놓음으로써 DBMS 변경에 따른 유연한 대처가 가능해짐.
* 특정 클래스가 SRP를 잘 지키고 있는지 확인하려면, "클래스 A가 자신을 (메서드를 통해 구현된 동작) 한다." 라는 명제가 명확하게 참이어야 함.
  * 휴대폰을 예로 들면, 음성 송수신은 직접 자신이 수행하는 동작이다.
  * 반면 충전이나 전화 걸고받기, 애플리케이션 다운로드 등등은 휴대폰이 자체적으로 수행하는 동작이 아니라 사용자에 의해 수행되어지는 동작이다.
  * 여기서 사용자에 의해 수행되어지는 동작들의 경우, 별도의 클래스를 만든 후 이 클래스를 통해 만들어진 인스턴스가 휴대폰 클래스를 참조할 수 있도록 구현되어야 한다.

<br>

### 개방-폐쇄 원칙(OCP, Open-Closed Principle)
* 소프트웨어를 구성하는 요소(모듈, 클래스, 메서드 등등)들은 확장에는 열려있고, 변경에는 닫혀있어야 한다는 원리.
* Java에서는 인터페이스(Interface)를 이용하여 OCP에 따른 구현을 가능하게 함.
* 추상화와 다형성을 추구하여 객체지향 프로그래밍이 주는 장점을 누릴 수 있음.
* 변경될 것과 변경되지 않아야할 것에 대한 구분을 명확하게 하도록 함.
  * 변경될 것은 쉽게 변경될 수 있도록 하고, 변경되지 않아야할 것은 변경된 것에 영향을 주지 않도록 해야 함(Side-Effect 방지).
  * 특정 클래스에 있는 메서드의 로직을 수정하게 되면, 이에 따른 Side-Effect가 발생할 수 있음. 이를 방지하기 위해, 그에 맞춘 테스트를 수행해야 함.
  * 가급적이면 특정 클래스에 있는 메서드의 수정사항이 발생했을 때, 그 클래스에 있는 메서드를 직접 수정하는 것을 지양해야 함.
  * 새로운 클래스에서 그에 해당하는 기능을 새로 구현하여 이를 확장해야 함.

<br>

### 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
* 부모 클래스를 상속받은 자식 클래스가 부모 클래스에서 구현한 행위(메서드)를 올바르게 수행해야 한다는 원리.
* 즉, 부모 클래스의 인스턴스를 자식 클래스의 인스턴스로 대신할 수 있어야 함.
  * 상속받은 자식 클래스의 인스턴스가 부모 클래스에 있는 메서드를 의도한대로 일관성있게 수행할 수 있는지 파악해야 함.
* LSP를 지키는 가장 간단한 방법은 해당 메서드를 다른 의도로 오버라이딩하지 않는 것. 만약 이를 지키기 어려운 경우, "IS-A" 관계의 상속보다는 "HAS-A" 관계의 위임을 통해 클래스 설계가 이루어져야 함.

<br>

### 인터페이스 분리 원칙(ISP, Interface Segregation Principle)


<br>

### 의존관계 역전 원칙(DIP, Dependency Inversion Principle)


<br>

#### 참고
* <한번 읽으면 두번 깨닫는 객체지향 프로그래밍> - 김동헌
