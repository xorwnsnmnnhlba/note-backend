# Tactical Design

### 전술적 설계(Tactical Design)
* 전략적 설계를 통해 나온 도메인 모델을 설계/구현에 반영하는 작업을 의미함.
* 거시적인 관점에서 봤을 때 전략적 설계도 중요하지만, 담당하는 모듈을 설계/구현하는 개발자 입장에서는 전술적 설계가 훨씬 더 중요함.
* 도메인 모델은 대표적으로 아래 네 가지로 구분할 수 있음.
  1. 엔티티(Entity) - 고유한 식별자를 가지고 있으며, 그 식별자로 동일한 객체인지 확인 가능.
  2. 값 객체(VO, Value Object) - 식별성보다는 여러 속성값에 따른 동등성 확인을 위해 사용하는 객체.
  3. 애그리거트(Aggregate)
  4. 리파지터리(Repository)

<br>

### 개체와 엔티티
* 개체: 현실세계에 대해 사람이 생각하는 개념이나 정보의 단위.
* 엔티티: 데이터베이스 테이블에 매핑된 클래스. 엔티티를 통해 만들어진 인스턴스는 각각의 식별자(Identifier)가 존재함.

<br>

### 동일성과 동등성
* 동일성(Identity): 두 객체가 동일한 식별자를 가진 경우를 의미함. Java에서는 비교연산자 ==을 이용하여 확인 가능.
* 동등성(Equality): 두 객체가 동일한 정보를 가진 경우를 의미함. Java에서는 동등성을 확인하기 위해 equals 메서드와 hashcode 메서드를 이용함.
* 동일하면 동등하지만, 동등하다고 해서 반드시 동일하다 할수는 없음.
  * 제조 일련번호(S/N, Serial Number)가 서로 다른 만원짜리 지폐 두 장이 놓인 경우, 동등성은 같지만 동일성은 다르다고 할 수 있음.

<br>

### 애그리거트(Aggregate)
* 연관성있는 엔티티와 VO를 하나로 묶은 집합체.
* 도메인 모델이 복잡해지면, 큰 그림에서 그에 대한 구조를 분석하는데 어려움을 겪게 됨. 이를 해소하기 위해 복잡하게 얽혀있는 여러 도메인들을 단순화하여 이해하기 쉽게 도와주는 역할을 수행함.
  * 추가 요구사항에 따른 코드 변경이 이루어질 때, 조금이라도 용이하게 변경이 이루어질 수 있게 해줌.
* 상위 수준에서 도메인 모델간의 관계를 파악할 수 있도록 도와주며, 모델에 대한 일관성을 관리하는 기준이 될 수 있음.
* 하나의 애그리거트에 속한 객체들은 다른 애그리거트에 속하지 않게 되며, 유사한 생명주기를 가지게 됨.

<br>

<figure><img src="./images/aggregates.png" alt=""></figure>

### 애그리거트 루트(Aggregate Root)
* 단순하게 애그리거트에 속한 객체를 포함하는 것을 넘어 애그리거트 전체를 관리하는 주체.
* 애그리거트에 속한 모든 객체들이 일관된 상태를 유지하기 위해 필요함.
* 애그리거트에 속한 객체는 애그리거트 루트에 직간접적으로 속하게 됨.
* 애그리거트 루트에서 제공한 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성과 불변식(Invariant)이 무너지지 않도록 구현해야 함.
* 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하지 않아야 함. 즉, 특정 애그리거트 루트에 해당하는 VO의 상태를 변경하기 위해 애그리거트 루트를 거쳐서만 변경 가능하도록 구현해야 함.
* 애그리거트 루트에 JPA를 매핑하는 경우, 엔티티이므로 @Entity를 넣어줘야 함.

<br>

### 애그리거트 트랜잭션 관리
* 애그리거트에 속한 객체의 일관성을 무너뜨리지 않게 하기위해 이에 대한 트랜잭션 처리가 필요함. 아래와 같이 두 가지 방법이 있음.
  * 선점 잠금(Pessimistic Lock)
    * 특정 애그리거트에 먼저 접근한 쓰레드가 그 애그리거트에 대한 사용이 끝날 때까지 다른 쓰레드가 해당 애그리거트를 수정하지 못하게 막는 방식.
    * Spring Data JPA의 경우, 해당 리파지터리 메서드에 @Lock(LockModeType.PESSIMISTIC_WRITE) 애노테이션을 넣어서 적용할 수 있음.
    * 잠금 순서에 따른 교착상태(Deadlock)가 발생하지 않도록 주의해야 함. Spring Data JPA의 경우, @QueryHints 애노테이션을 이용하여 쿼리 힌트를 지정할 수 있음. 쿼리 힌트를 지원하는 DBMS에 한해 적용 가능함.
  * 비선점 잠금(Optimistic Lock)
    * 특정 쓰레드에 의해 변경된 데이터를 DBMS에 반영하는 시점에 변경 가능여부를 확인하는 방식. 이를 위해 대상 애그리거트 version 필드에 @Version 애노테이션을 붙여서 관리함.
    * JPA는 엔티티가 변경되어 UPDATE 쿼리를 실행할 때 @Version에 명시한 필드를 이용하여 비선점 잠금 쿼리를 실행함.

<br>

### 리파지터리(Repository)
* 애그리거트 단위로 영속성을 처리하는 주체. 애그리거트를 관리하기 위한 컬렉션(Collection)처럼 동작함.
* 하나의 애그리거트에 대해 하나의 리파지터리가 존재할 때, Spring Data JPA에 있는 CascadeType.ALL, orphanRemoval=true 옵션을 이용하여 안정적으로 작동할 수 있도록 해줌.

<br>

#### 참고
* https://kalele.io/modeling-aggregates-with-ddd-and-entity-framework/
* https://www.inflearn.com/questions/27918/%EB%8F%84%EB%A9%94%EC%9D%B8%EC%84%A4%EA%B3%84-%EA%B4%80%EB%A0%A8-%EC%A7%88%EB%AC%B8%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4
* <도메인 주도 개발 시작하기: DDD 핵심 개념 정리부터 구현까지> - 최범균

#### 배워가는 것들
* 전술적 설계에 대한 개념을 익힐 수 있었다.
* 엔티티와 값 객체 비교 시에 쓰이는 동일성과 동등성에 대해 익힐 수 있었다.
* 애그리거트와 애그리거트 루트에 대한 개념을 익힐 수 있었다. 전술적 설계를 적용할 때 유의해야 할 사항들을 파악할 수 있었다.
* 전술적 설계에서 쓰이는 개념들을 잘 알고 있는것도 중요하지만, 더 중요한 것은 이를 바탕으로 실제 설계시에 올바르게 적용해보는 것이다. 경험이 필요한 요소이기에, 향후 실무 수행 시 적용 가능한 부분부터 하나하나 해보려 한다.
